import{addDoc as v,collection as g,serverTimestamp as m,doc as p,updateDoc as D,query as d,where as u,orderBy as E,getDocs as f,getDoc as k,onSnapshot as B,writeBatch as S,arrayUnion as C,limit as b,deleteDoc as Q,increment as U}from"./index.esm-BqhvDsTW.js";import{x as o}from"./firebase-CYVISPkl.js";import"./index.esm-B6eNFOH0.js";import"./iframe-DKRQQh4j.js";import"../sb-preview/runtime.js";import"./Layout.stories-C-YYUlYF.js";import"./jsx-runtime-BTJTZTIL.js";import"./index-ChsGqxH_.js";import"./index-CJ_LmFaV.js";import"./_commonjsHelpers-D6-XlEtG.js";import"./Card-BhywAxIU.js";class q{async createConversation(r){try{return{success:!0,data:{id:(await v(g(o,"conversations"),{...r,createdAt:m(),updatedAt:m(),lastActivity:m(),isActive:!0,isArchived:!1})).id,...r,createdAt:new Date,updatedAt:new Date,lastActivity:new Date,isActive:!0,isArchived:!1}}}catch(e){return console.error("Error creating conversation:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async updateConversation(r,e){try{const t=p(o,"conversations",r);return await D(t,{...e,updatedAt:m()}),{success:!0}}catch(t){return console.error("Error updating conversation:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async getUserConversations(r){try{const e=d(g(o,"conversations"),u("participants","array-contains",r),u("isActive","==",!0),E("lastActivity","desc"));return{success:!0,data:(await f(e)).docs.map(s=>({id:s.id,...s.data()}))}}catch(e){return console.error("Error getting user conversations:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async getConversationById(r){try{const e=p(o,"conversations",r),t=await k(e);return t.exists()?{success:!0,data:{id:t.id,...t.data()}}:{success:!1,error:"Not found"}}catch(e){return console.error("Error fetching conversation by id:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}subscribeToMessages(r,e){try{const t=d(g(o,"messages"),u("conversationId","==",r),E("timestamp","asc"));return B(t,c=>{const s=c.docs.map(a=>({id:a.id,...a.data()}));e(s)})}catch(t){console.error("Error subscribing to messages:",t);return}}async sendMessage(r,e){try{return{success:!0,data:{id:(await v(g(o,"messages"),{...r,conversationId:e,timestamp:m(),createdAt:m(),updatedAt:m(),deliveryStatus:{status:"delivered",timestamp:m()}})).id,...r,conversationId:e,timestamp:new Date,createdAt:new Date,updatedAt:new Date}}}catch(t){return console.error("Error sending message:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async markMessagesAsRead(r,e){try{const t=d(g(o,"messages"),u("conversationId","==",r),u("senderId","!=",e)),c=await f(t),s=S(o);return c.docs.forEach(a=>{const n=a.ref;s.update(n,{[`readBy.${e}`]:m(),"deliveryStatus.status":"read","deliveryStatus.timestamp":m()})}),await s.commit(),{success:!0}}catch(t){return console.error("Error marking messages as read:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async addReaction(r,e,t){try{const c=p(o,"messages",r);return await D(c,{[`reactions.${t}`]:C(e),updatedAt:m()}),{success:!0}}catch(c){return console.error("Error adding reaction:",c),{success:!1,error:c instanceof Error?c.message:"Unknown error"}}}async searchRequests(r){try{let e=d(g(o,"requests"));if(r.type&&(e=d(e,u("type","==",r.type))),r.status&&(e=d(e,u("status","==",r.status))),r.urgency&&(e=d(e,u("urgency","==",r.urgency))),r.location&&(e=d(e,u("location",">=",r.location),u("location","<=",r.location+""))),r.sortBy){const s=r.sortOrder==="desc"?"desc":"asc";e=d(e,E(r.sortBy,s))}else e=d(e,E("createdAt","desc"));return r.limit&&(e=d(e,b(r.limit))),{success:!0,data:(await f(e)).docs.map(s=>({id:s.id,...s.data()}))}}catch(e){return console.error("Error searching requests:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async searchOfferings(r){try{let e=d(g(o,"offerings"));if(r.type&&(e=d(e,u("type","==",r.type))),r.status&&(e=d(e,u("status","==",r.status))),r.location&&(e=d(e,u("location",">=",r.location),u("location","<=",r.location+""))),r.sortBy){const s=r.sortOrder==="desc"?"desc":"asc";e=d(e,E(r.sortBy,s))}else e=d(e,E("createdAt","desc"));return r.limit&&(e=d(e,b(r.limit))),{success:!0,data:(await f(e)).docs.map(s=>({id:s.id,...s.data()}))}}catch(e){return console.error("Error searching offerings:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async addRating(r,e,t,c,s){try{const a={targetId:r,targetType:e,rating:t,review:c||"",userId:s||"anonymous",timestamp:m()};return await v(g(o,"ratings"),a),await this.updateAverageRating(r,e),{success:!0}}catch(a){return console.error("Error adding rating:",a),{success:!1,error:a instanceof Error?a.message:"Unknown error"}}}async updateAverageRating(r,e){try{const t=d(g(o,"ratings"),u("targetId","==",r),u("targetType","==",e)),s=(await f(t)).docs.map(a=>a.data().rating);if(s.length>0){const a=s.reduce((l,y)=>l+y,0)/s.length,n=s.length,h=e==="user"?"users":`${e}s`,i=p(o,h,r);await D(i,{"rating.average":a,"rating.count":n,updatedAt:m()})}}catch(t){console.error("Error updating average rating:",t)}}async recordAnalytics(r,e){try{const t={eventType:r,data:e,timestamp:m(),date:new Date().toISOString().split("T")[0]};return await v(g(o,"analytics"),t),{success:!0}}catch(t){return console.error("Error recording analytics:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async getAnalyticsSummary(r,e){try{const t=d(g(o,"analytics"),u("date",">=",r),u("date","<=",e)),s=(await f(t)).docs.map(n=>n.data()),a={totalEvents:s.length,eventsByType:{},dailyBreakdown:{}};return s.forEach(n=>{a.eventsByType[n.eventType]=(a.eventsByType[n.eventType]||0)+1,a.dailyBreakdown[n.date]=(a.dailyBreakdown[n.date]||0)+1}),{success:!0,data:a}}catch(t){return console.error("Error getting analytics summary:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async getDemoContent(){try{return{success:!0,data:(await f(g(o,"demo_content"))).docs.map(t=>({id:t.id,...t.data()}))}}catch(r){return console.error("Error fetching demo content:",r),{success:!1,error:r instanceof Error?r.message:"Unknown error"}}}async addDemoContent(r){try{return{success:!0,data:(await v(g(o,"demo_content"),{...r,createdAt:m()})).id}}catch(e){return console.error("Error adding demo content:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async deleteDemoContent(r){try{return await Q(p(o,"demo_content",r)),{success:!0}}catch(e){return console.error("Error deleting demo content:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async recordHopePoints(r,e,t,c,s,a=1){try{const n=Math.max(0,Math.floor(c*a)),h={actorId:r,receiverId:e,category:t,amount:n,reason:s||"",timestamp:m()};await v(g(o,"hope_ledger"),h);const i=p(o,"users",e);return await D(i,{hopePoints:U(n),[`hopePointsBreakdown.${t}`]:U(n),updatedAt:m()}),{success:!0}}catch(n){return console.error("Error recording hope points:",n),{success:!1,error:n instanceof Error?n.message:"Unknown error"}}}async getLeaderboard(r){try{let e=d(g(o,"hope_ledger")),s=(await f(e)).docs.map(i=>({id:i.id,...i.data()}));if(r!=null&&r.startDate||r!=null&&r.endDate){const i=r!=null&&r.startDate?new Date(r.startDate):new Date("1970-01-01"),l=r!=null&&r.endDate?new Date(r.endDate):new Date;s=s.filter(y=>{const A=y.timestamp&&y.timestamp.toDate?y.timestamp.toDate():y.timestamp?new Date(y.timestamp):null;return A?A>=i&&A<=l:!1})}const a={};s.forEach(i=>{const l=i.receiverId,y=Number(i.amount||0);a[l]=(a[l]||0)+y});const n=Object.entries(a).map(([i,l])=>({id:i,points:l}));if(r!=null&&r.role){const l=(await f(g(o,"users"))).docs.map(w=>({id:w.id,...w.data()})),y=new Set(l.filter(w=>w.role===r.role).map(w=>w.id));return{success:!0,data:n.filter(w=>y.has(w.id)).sort((w,R)=>R.points-w.points).slice(0,r.limit||100)}}return{success:!0,data:n.sort((i,l)=>l.points-i.points).slice(0,(r==null?void 0:r.limit)||100)}}catch(e){return console.error("Error getting leaderboard:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async getPreaggregatedGlobal(){try{const r=p(o,"leaderboard_aggregates","global"),e=await k(r);if(!e.exists())return{success:!0,data:[]};const c=(e.data()||{}).totals||{};return{success:!0,data:Object.entries(c).map(([n,h])=>{const i=h||{};return{id:n,score:Number(i.score||0),rawPoints:Number(i.rawPoints||0),breakdown:i.breakdown||{},commendations:i.commendations||{}}}).sort((n,h)=>h.score-n.score)}}catch(r){return console.error("Error reading preaggregated global leaderboard:",r),{success:!1,error:r instanceof Error?r.message:"Unknown error"}}}}const L=new q;export{q as EnhancedFirebaseService,L as enhancedFirebaseService};
